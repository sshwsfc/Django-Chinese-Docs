============================
Django模板语言
============================

.. admonition:: 关于本文档

    本文档介绍了Django模板系统语言的语法.
    如果你希望从一个更技术的角度来看它是如何工作的和如何扩展
    它,请参阅 :doc:`/ref/templates/api` .

Django模板语言设计的初衷是为了获得效率和易用性之间的平衡.
HTML使用者会感觉到他设计的很舒服.如果你有使用其他基于文本的模板语言如 Smarty_
或 CheetahTemplate_ 的使用经验,你会感觉到使用Django模板语言和那些东西没什么两样.

.. admonition:: 哲理

    如果你有编程背景,或者你使用过PHP等嵌入HTML的程序语言,你要牢记,
    Django的模板系统是不是简单的把Python嵌入到HTML中.
    它的设计是:模板系统旨在展示内容,而不是程序逻辑.

    Django的模板系统提供的标签,其功能类似于一些编程结构 -- :ttag:`if` 标签用于布尔值测试,
    :ttag:`for` 标签用来做for循环, 等等.但这些都不是简单的执行相应的Python代码,模板系统不会执行任意的Python表达式.
    通常情况下, 模板系统仅支持接下来列出的这些标签和过滤 (仅当需要时你可以添加 :doc:`你自己的扩展
    </howto/custom-template-tags>` 到模板语法中).

.. _`The Django template language: For Python programmers`: ../templates_python/
.. _Smarty: http://smarty.php.net/
.. _CheetahTemplate: http://www.cheetahtemplate.org/

模板
=========

.. highlightlang:: html+django

模板是一个简单的文本文件.它可以生成任何基于文本的格式（如 HTML,XML,CSV等）.

模板中包含的 **变量** 被替换为变量的值, **标签** 被替换为相应的模板控制逻辑.

下面的一小段模板代码可以说明一些基本的内容. 文中的每个元素都将在后面解释.::

    {% extends "base_generic.html" %}

    {% block title %}{{ section.title }}{% endblock %}

    {% block content %}
    <h1>{{ section.title }}</h1>

    {% for story in story_list %}
    <h2>
      <a href="{{ story.get_absolute_url }}">
        {{ story.headline|upper }}
      </a>
    </h2>
    <p>{{ story.tease|truncatewords:"100" }}</p>
    {% endfor %}
    {% endblock %}

.. admonition:: 哲理

    为什么要使用基于文本的模板,而不是基于XML语法的（如Zope的TAL）？
    我们希望Django的模板语言不止是 XML/HTML.
    在网络世界,它可以不止被用在电子邮件,JavaScript和CSV中.
    您可以在任何文本格式中使用它.

    哦,还有一件事: 让人写XML, 那就是虐待!

变量
=========

变量看起来是这样的: ``{{ 变量 }}``. 当模板系统遇到一个变量, 他直接被替换为他的值.
变量名由字母数字和下划线 (``"_"``)组成. 点字符 (``"."``) 也可以出现在变量名中,但他有特殊的含义.比如下面的.
更重要的是, *变量名中不能有空格或其他的标点符号.*

使用点 (``.``) 来访问变量的属性.

.. admonition:: 幕后

    从技术上讲,当模板系统遇到一个点,它会尝试下面的动作,顺序如下:

    * 字典查询
    * 属性查询
    * 方法调用
    * 列表索引查找

在上面的例子中, ``{{ section.title }}`` 将被替换为这个对象的title属性值.

如果你使用一个不存在的变量,模板系统会替换它为settings中的 :setting:`TEMPLATE_STRING_IF_INVALID` 值,在默认情况下他被指定为 ``''`` (空字符串).

过滤器(Filters)
===============

通过使用 **过滤器** ,您可以修改变量的显示.

过滤器用起来像这样： ``{{ name|lower }}`` .
通过过滤器 :tfilter:`lower` 变量 ``{{ name }}`` 变为了小写字符.
通过管道符 (``|``) 间隔变量和过滤器来使用过滤器.

过滤器可以是 "链式的". 一个过滤器的输出作为下一个过滤器的输入.
``{{ text|escape|linebreaks }}`` 是一种常用的转换方式,
在这之后换行符被替换为了 ``<p>`` 标签.

有些过滤器是带有参数的. 一个带参数的过滤器看起来像这样: ``{{
bio|truncatewords:30 }}``. 他会显示 ``bio`` 变量的前30个字符.

如果过滤器的参数包含空格, 那么参数必须被引号包起来; 比如, 用逗号和空格来间隔列表内的元素, 你可以像这样用
``{{ list|join:", " }}``.

Django提供了约30个内置的过滤器. 有关这些过滤器你可以在
:ref:`内置过滤器参考 <ref-templates-builtins-filters>` 中找到更详尽的描述.
这儿有一些过滤器的例子,可以让你尝到一些过滤器的甜头:

:tfilter:`default`
    如果一个变量是假的或空的,使用默认值. 否则,使用变量的值

    例如::

        {{ value|default:"nothing" }}

    如果 ``value`` 没有提供或者为空，那么他将显示为 "``nothing``" 。

:tfilter:`length`
    返回的值的长度。可以被用于字符串或者列表;

    for example::

        {{ value|length }}

    如果 ``value`` 为 ``['a', 'b', 'c', 'd']``, 那么他将被显示为 ``4``.

:tfilter:`striptags`
    去掉所有 [X]HTML 标签. 比如::

        {{ value|striptags }}

    如果 ``value`` 为 ``"<b>Joel</b> <button>is</button> a
    <span>slug</span>"``, 那么输出就会是 ``"Joel is a slug"``.

这些只是几个例子，请参阅  :ref:`内置过滤器参考 <ref-templates-builtins-filters>` 的完整列表。

您还可以创建自己的自定义模板过滤器，请参见 :doc:`/howto/custom-template-tags`.

.. admonition:: 查看更多

    Django的管理界面可以在一个给定的站点中包含所有的模板标签和过滤器的完整参考。
    请参阅 :doc:`/ref/contrib/admin/admindocs`.

标签(Tags)
==========

标签看起来像这样: ``{% tag %}``. 标签要比变量更复杂: 有些标签会创建一段文本,
有些标签会控制输出流的方式比如循环或逻辑条件, 还有些标签会添加一些扩展内容到模板中,
比如另外的标签和过滤器.

有些标签在使用时需要有开始和结束标签 (像这样 ``{% tag %} ... 内容
... {% endtag %}``).

Django内置了大约二十几个标签. 你可以在 :ref:`内置标签参考 <ref-templates-builtins-tags>` 阅读有关内置标签的内容.
为了让你尝试有什么可用的, 这里有一些常用标签的例子:

:ttag:`for`
    循环数组中的每个元素.  比如, 显示列表 ``athlete_list`` 中每个元素的 ``name`` 属性::

        <ul>
        {% for athlete in athlete_list %}
            <li>{{ athlete.name }}</li>
        {% endfor %}
        </ul>

:ttag:`if` and ``else``
    判断一个变量的布尔值, 如果它为 "true" 则显示 ``if`` 块儿内的内容, 否则显示 ``else`` 块儿内的文字::

        {% if athlete_list %}
            Number of athletes: {{ athlete_list|length }}
        {% else %}
            No athletes.
        {% endif %}

    在上面的例子中, 如果 ``athlete_list`` 不是空的, 那么变量 ``{{ athlete_list|length }}`` 就会被显示出来.

    也可以在 :ttag:`if` 标签里使用过滤器和各种操作符::

        {% if athlete_list|length > 1 %}
           Team: {% for athlete in athlete_list %} ... {% endfor %}
        {% else %}
           Athlete: {{ athlete_list.0.name }}
        {% endif %}

:ttag:`block` and :ttag:`extends`
    请看 `模板继承`_ (在下面), 一个强大的方法, 在模板上切割下来的"样板".

以上的例子只是整个标签列表的一小部分; 请参看
:ref:`内置标签参考 <ref-templates-builtins-tags>` 完整阅览.

您还可以创建自己的自定义模板标签, 请参看
:doc:`/howto/custom-template-tags`.

.. admonition:: 查看更多

    Django的管理界面可以在一个给定的站点中包含所有的模板标签和过滤器的完整参考。
    请参阅 :doc:`/ref/contrib/admin/admindocs`.

注释(Comments)
==============

要注释掉行的一部分,在模板中使用注释语法: ``{# #}``.

例如,该模板将呈现为 ``'hello'``::

    {# greeting #}hello

注释可以包含任何模板代码, 使其生效或无效. 例如::

    {# {% if foo %}bar{% else %} #}

这个语法只能用于单行注释 (不允许在 ``{#`` 和 ``#}`` 之间换行).
如果您需要注释掉多行部分的模板, 参见 :ttag:`comment` 标签.

.. _template-inheritance:

模板继承
=========

The most powerful -- and thus the most complex -- part of Django's template
engine is template inheritance. Template inheritance allows you to build a base
"skeleton" template that contains all the common elements of your site and
defines **blocks** that child templates can override.

It's easiest to understand template inheritance by starting with an example::

    <!DOCTYPE html>
    <html lang="en">
    <head>
        <link rel="stylesheet" href="style.css" />
        <title>{% block title %}My amazing site{% endblock %}</title>
    </head>

    <body>
        <div id="sidebar">
            {% block sidebar %}
            <ul>
                <li><a href="/">Home</a></li>
                <li><a href="/blog/">Blog</a></li>
            </ul>
            {% endblock %}
        </div>

        <div id="content">
            {% block content %}{% endblock %}
        </div>
    </body>
    </html>

This template, which we'll call ``base.html``, defines a simple HTML skeleton
document that you might use for a simple two-column page. It's the job of
"child" templates to fill the empty blocks with content.

In this example, the :ttag:`block` tag defines three blocks that child
templates can fill in. All the :ttag:`block` tag does is to tell the template
engine that a child template may override those portions of the template.

A child template might look like this::

    {% extends "base.html" %}

    {% block title %}My amazing blog{% endblock %}

    {% block content %}
    {% for entry in blog_entries %}
        <h2>{{ entry.title }}</h2>
        <p>{{ entry.body }}</p>
    {% endfor %}
    {% endblock %}

The :ttag:`extends` tag is the key here. It tells the template engine that
this template "extends" another template. When the template system evaluates
this template, first it locates the parent -- in this case, "base.html".

At that point, the template engine will notice the three :ttag:`block` tags
in ``base.html`` and replace those blocks with the contents of the child
template. Depending on the value of ``blog_entries``, the output might look
like::

    <!DOCTYPE html>
    <html lang="en">
    <head>
        <link rel="stylesheet" href="style.css" />
        <title>My amazing blog</title>
    </head>

    <body>
        <div id="sidebar">
            <ul>
                <li><a href="/">Home</a></li>
                <li><a href="/blog/">Blog</a></li>
            </ul>
        </div>

        <div id="content">
            <h2>Entry one</h2>
            <p>This is my first entry.</p>

            <h2>Entry two</h2>
            <p>This is my second entry.</p>
        </div>
    </body>
    </html>

Note that since the child template didn't define the ``sidebar`` block, the
value from the parent template is used instead. Content within a ``{% block %}``
tag in a parent template is always used as a fallback.

You can use as many levels of inheritance as needed. One common way of using
inheritance is the following three-level approach:

* Create a ``base.html`` template that holds the main look-and-feel of your
  site.
* Create a ``base_SECTIONNAME.html`` template for each "section" of your
  site. For example, ``base_news.html``, ``base_sports.html``. These
  templates all extend ``base.html`` and include section-specific
  styles/design.
* Create individual templates for each type of page, such as a news
  article or blog entry. These templates extend the appropriate section
  template.

This approach maximizes code reuse and makes it easy to add items to shared
content areas, such as section-wide navigation.

Here are some tips for working with inheritance:

* If you use :ttag:`{% extends %}<extends>` in a template, it must be the first template
  tag in that template. Template inheritance won't work, otherwise.

* More :ttag:`{% block %}<block>` tags in your base templates are better. Remember,
  child templates don't have to define all parent blocks, so you can fill
  in reasonable defaults in a number of blocks, then only define the ones
  you need later. It's better to have more hooks than fewer hooks.

* If you find yourself duplicating content in a number of templates, it
  probably means you should move that content to a ``{% block %}`` in a
  parent template.

* If you need to get the content of the block from the parent template,
  the ``{{ block.super }}`` variable will do the trick. This is useful
  if you want to add to the contents of a parent block instead of
  completely overriding it. Data inserted using ``{{ block.super }}`` will
  not be automatically escaped (see the `next section`_), since it was
  already escaped, if necessary, in the parent template.

* For extra readability, you can optionally give a *name* to your
  ``{% endblock %}`` tag. For example::

      {% block content %}
      ...
      {% endblock content %}

  In larger templates, this technique helps you see which ``{% block %}``
  tags are being closed.

Finally, note that you can't define multiple :ttag:`block` tags with the same
name in the same template. This limitation exists because a block tag works in
"both" directions. That is, a block tag doesn't just provide a hole to fill --
it also defines the content that fills the hole in the *parent*. If there were
two similarly-named :ttag:`block` tags in a template, that template's parent
wouldn't know which one of the blocks' content to use.

.. _next section: #automatic-html-escaping
.. _automatic-html-escaping:

自动HTML转义
=============

When generating HTML from templates, there's always a risk that a variable will
include characters that affect the resulting HTML. For example, consider this
template fragment::

    Hello, {{ name }}.

At first, this seems like a harmless way to display a user's name, but consider
what would happen if the user entered his name as this::

    <script>alert('hello')</script>

With this name value, the template would be rendered as::

    Hello, <script>alert('hello')</script>

...which means the browser would pop-up a JavaScript alert box!

Similarly, what if the name contained a ``'<'`` symbol, like this?

.. code-block:: html

    <b>username

That would result in a rendered template like this::

    Hello, <b>username

...which, in turn, would result in the remainder of the Web page being bolded!

Clearly, user-submitted data shouldn't be trusted blindly and inserted directly
into your Web pages, because a malicious user could use this kind of hole to
do potentially bad things. This type of security exploit is called a
`Cross Site Scripting`_ (XSS) attack.

To avoid this problem, you have two options:

* One, you can make sure to run each untrusted variable through the
  :tfilter:`escape` filter (documented below), which converts potentially
  harmful HTML characters to unharmful ones. This was the default solution
  in Django for its first few years, but the problem is that it puts the
  onus on *you*, the developer / template author, to ensure you're escaping
  everything. It's easy to forget to escape data.

* Two, you can take advantage of Django's automatic HTML escaping. The
  remainder of this section describes how auto-escaping works.

By default in Django, every template automatically escapes the output
of every variable tag. Specifically, these five characters are
escaped:

* ``<`` is converted to ``&lt;``
* ``>`` is converted to ``&gt;``
* ``'`` (single quote) is converted to ``&#39;``
* ``"`` (double quote) is converted to ``&quot;``
* ``&`` is converted to ``&amp;``

Again, we stress that this behavior is on by default. If you're using Django's
template system, you're protected.

.. _Cross Site Scripting: http://en.wikipedia.org/wiki/Cross-site_scripting

如何关闭它
-----------

If you don't want data to be auto-escaped, on a per-site, per-template level or
per-variable level, you can turn it off in several ways.

Why would you want to turn it off? Because sometimes, template variables
contain data that you *intend* to be rendered as raw HTML, in which case you
don't want their contents to be escaped. For example, you might store a blob of
HTML in your database and want to embed that directly into your template. Or,
you might be using Django's template system to produce text that is *not* HTML
-- like an email message, for instance.

对于单个变量
~~~~~~~~~~~~~~~~~~~~~~~~

To disable auto-escaping for an individual variable, use the :tfilter:`safe`
filter::

    This will be escaped: {{ data }}
    This will not be escaped: {{ data|safe }}

Think of *safe* as shorthand for *safe from further escaping* or *can be
safely interpreted as HTML*. In this example, if ``data`` contains ``'<b>'``,
the output will be::

    This will be escaped: &lt;b&gt;
    This will not be escaped: <b>

对于模板文本块
~~~~~~~~~~~~~~~~~~~

To control auto-escaping for a template, wrap the template (or just a
particular section of the template) in the :ttag:`autoescape` tag, like so::

    {% autoescape off %}
        Hello {{ name }}
    {% endautoescape %}

The :ttag:`autoescape` tag takes either ``on`` or ``off`` as its argument. At
times, you might want to force auto-escaping when it would otherwise be
disabled. Here is an example template::

    Auto-escaping is on by default. Hello {{ name }}

    {% autoescape off %}
        This will not be auto-escaped: {{ data }}.

        Nor this: {{ other_data }}
        {% autoescape on %}
            Auto-escaping applies again: {{ name }}
        {% endautoescape %}
    {% endautoescape %}

The auto-escaping tag passes its effect onto templates that extend the
current one as well as templates included via the :ttag:`include` tag,
just like all block tags. For example::

    # base.html

    {% autoescape off %}
    <h1>{% block title %}{% endblock %}</h1>
    {% block content %}
    {% endblock %}
    {% endautoescape %}


    # child.html

    {% extends "base.html" %}
    {% block title %}This & that{% endblock %}
    {% block content %}{{ greeting }}{% endblock %}

Because auto-escaping is turned off in the base template, it will also be
turned off in the child template, resulting in the following rendered
HTML when the ``greeting`` variable contains the string ``<b>Hello!</b>``::

    <h1>This & that</h1>
    <b>Hello!</b>

注意
-----

Generally, template authors don't need to worry about auto-escaping very much.
Developers on the Python side (people writing views and custom filters) need to
think about the cases in which data shouldn't be escaped, and mark data
appropriately, so things Just Work in the template.

If you're creating a template that might be used in situations where you're
not sure whether auto-escaping is enabled, then add an :tfilter:`escape` filter
to any variable that needs escaping. When auto-escaping is on, there's no
danger of the :tfilter:`escape` filter *double-escaping* data -- the
:tfilter:`escape` filter does not affect auto-escaped variables.

.. _string-literals-and-automatic-escaping:

字符串和自动转义
-----------------

As we mentioned earlier, filter arguments can be strings::

    {{ data|default:"This is a string literal." }}

All string literals are inserted **without** any automatic escaping into the
template -- they act as if they were all passed through the :tfilter:`safe`
filter. The reasoning behind this is that the template author is in control of
what goes into the string literal, so they can make sure the text is correctly
escaped when the template is written.

This means you would write ::

    {{ data|default:"3 &lt; 2" }}

...rather than ::

    {{ data|default:"3 < 2" }}  <-- Bad! Don't do this.

This doesn't affect what happens to data coming from the variable itself.
The variable's contents are still automatically escaped, if necessary, because
they're beyond the control of the template author.

.. _template-accessing-methods:

访问方法调用
=============

Most method calls attached to objects are also available from within templates.
This means that templates have access to much more than just class attributes
(like field names) and variables passed in from views. For example, the Django
ORM provides the :ref:`"entry_set"<topics-db-queries-related>` syntax for
finding a collection of objects related on a foreign key. Therefore, given
a model called "comment" with a foreign key relationship to a model called
"task" you can loop through all comments attached to a given task like this::

    {% for comment in task.comment_set.all %}
        {{ comment }}
    {% endfor %}

Similarly, :doc:`QuerySets</ref/models/querysets>` provide a ``count()`` method
to count the number of objects they contain. Therefore, you can obtain a count
of all comments related to the current task with::

    {{ task.comment_set.all.count }}

And of course you can easily access methods you've explicitly defined on your
own models::

    # In model
    class Task(models.Model):
        def foo(self):
            return "bar"

    # In template
    {{ task.foo }}

Because Django intentionally limits the amount of logic processing available
in the template language, it is not possible to pass arguments to method calls
accessed from within templates. Data should be calculated in views, then passed
to templates for display.

.. _loading-custom-template-libraries:

自定义标签和过滤器库
====================

Certain applications provide custom tag and filter libraries. To access them in
a template, use the :ttag:`load` tag::

    {% load comments %}

    {% comment_form for blogs.entries entry.id with is_public yes %}

In the above, the :ttag:`load` tag loads the ``comments`` tag library, which then
makes the ``comment_form`` tag available for use. Consult the documentation
area in your admin to find the list of custom libraries in your installation.

The :ttag:`load` tag can take multiple library names, separated by spaces.
Example::

    {% load comments i18n %}

See :doc:`/howto/custom-template-tags` for information on writing your own custom
template libraries.

自定义库和模板继承
------------------

When you load a custom tag or filter library, the tags/filters are only made
available to the current template -- not any parent or child templates along
the template-inheritance path.

For example, if a template ``foo.html`` has ``{% load comments %}``, a child
template (e.g., one that has ``{% extends "foo.html" %}``) will *not* have
access to the comments template tags and filters. The child template is
responsible for its own ``{% load comments %}``.

This is a feature for the sake of maintainability and sanity.
